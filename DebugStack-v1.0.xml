<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2017.2.2 (Build 865U)" ts="2018-10-07 04:34:49">
<Project name="DebugStack" LastModified="2018-10-07 04:25:27.227164">
  <Items>
    <ProjectItem name="DebugStackDefines.INC" type="MAC"></ProjectItem>
    <ProjectItem name="MasterLib.Utils.Exception.DebugStack" type="CLS"></ProjectItem>
    <ProjectItem name="Examples.DebugStack" type="CLS"></ProjectItem>
  </Items>
</Project>


<Routine name="DebugStackDefines" type="INC" timestamp="64688,29979.17433"><![CDATA[
#Include %occIO

#define InitialiseDebugStack	Set tDebugStack = $get(tDebugStack, ##class(MasterLib.Utils.Exception.DebugStack).%New())
#define AddDebugInfo(%Value)	Do tDebugStack.AddInfoToStack($$$CurrentClass, $$$CurrentMethod, %Value)
#define AddDebugStack(%Stack)	Do tDebugStack.AddStackToStack(%Stack)
#define DebugStackToString		tDebugStack.ToString()
#define DebugStackVariableName	tDebugStack

]]></Routine>


<Class name="Examples.DebugStack">
<Description>
A simple example to illustrate the use of the debug stack</Description>
<IncludeCode>DebugStackDefines</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeChanged>64928,16376.311006</TimeChanged>
<TimeCreated>64928,15875.233252</TimeCreated>

<Method name="TestDebugStack">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set sc = $$$OK
	$$$InitialiseDebugStack
	try
	{
		set tVal = 5
		$$$AddDebugInfo("Calling Method InnerStackTest with value: " _ tVal)
		
		set sc = ..TestInnterStack(tVal, .tDebStackP)
		$$$AddDebugStack(tDebStackP)
		if ($$$ISERR(sc)) {
			throw
		}
		$$$AddDebugInfo("TestInnerStack completed OK")
		
		// For example purposes the debug stack will be written out
		w $$$DebugStackToString
		
	} catch tEx {
		
		// Optionally log the debugstack stream using a persistent class to enable devops to evaluate system exceptions.
		// Optional on Ensemble: Send an Alert containing the %Id value of the stored exception containing the debugstack
	}
	quit sc
]]></Implementation>
</Method>

<Method name="TestInnterStack">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pVal:%Integer,&pDebStack:MasterLib.Utils.Exception.DebugStack]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set sc = $$$OK
	$$$InitialiseDebugStack
	try
	{
		$$$AddDebugInfo("pVal argument: " _ pVal)
		
		set tMyVal = pVal + 10
		$$$AddDebugInfo("tMyVal: " _ tMyVal)
		
		$$$AddDebugInfo("Calling TestThirdLevelStack with tMyVal: " _ tMyVal)
		set sc = ..TestThirdLevelStack(tMyVal, .tDebStackP)
		$$$AddDebugStack(tDebStackP)
		if ($$$ISERR(sc)) {
			throw
		}
		$$$AddDebugInfo("TestThirdLevelStack completed OK")
		
	} catch tEx {
		set:(sc=$$$OK) sc = tEx.AsStatus()
		$$$AddDebugInfo("Exception handled sc: " _ $System.Status.GetErrorText(sc))
	}
	set pDebStack = $$$DebugStackVariableName
	quit sc
]]></Implementation>
</Method>

<Method name="TestThirdLevelStack">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pVal:%Integer,&pDebStack:MasterLib.Utils.Exception.DebugStack]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set sc = $$$OK
	$$$InitialiseDebugStack
	try
	{
		$$$AddDebugInfo("pVal argument: " _ pVal)
		
		set tFinalVal = pVal + 20
		$$$AddDebugInfo("tFinalVal: " _ tFinalVal)
		
	} catch tEx {
		set:(sc=$$$OK) sc = tEx.AsStatus()
		$$$AddDebugInfo("Exception handled sc: " _ $System.Status.GetErrorText(sc))
	}
	set pDebStack = $$$DebugStackVariableName
	quit sc
]]></Implementation>
</Method>
</Class>


<Class name="MasterLib.Utils.Exception.DebugStack">
<Description><![CDATA[
Debug Stack Class used for building a stack of information at runtime.<be>
The stack can be placed into a stream which can be stored for use later.]]></Description>
<Super>%RegisteredObject</Super>
<TimeChanged>64928,14707.054575</TimeChanged>
<TimeCreated>64834,28507.908804</TimeCreated>

<Property name="StackLines">
<Description>
A semi-colon separated list of values. Contains ClassName, MethodName and Debug Information. It can also contain a subset of StackLines Private</Description>
<Type>%Library.ListOfDataTypes</Type>
<Private>1</Private>
</Property>

<Property name="StackOutput">
<Description>
A semi-colon separated list of values. Contains ClassName, MethodName and Debug Information. It can also contain a subset of StackLines Private</Description>
<Type>%Stream.GlobalCharacter</Type>
<Private>1</Private>
</Property>

<Method name="AddInfoToStack">
<Description>
Method to Add info to the DebugStack, Data passed in.</Description>
<FormalSpec>pClass:%String,pMethod:%String,pStackInfo:%String</FormalSpec>
<Implementation><![CDATA[
	set tNewElement = pClass_";"_pMethod_";"_pStackInfo
	do ..StackLines.Insert(tNewElement)
]]></Implementation>
</Method>

<Method name="AddStackToStack">
<Description>
Method to Add info to the DebugStack, Stack passed in.</Description>
<FormalSpec>pStack:MasterLib.Utils.Exception.DebugStack</FormalSpec>
<Implementation><![CDATA[	do ..StackLines.Insert(pStack.StackLines)
]]></Implementation>
</Method>

<Method name="StackToStream">
<Description>
Private method called to help indent the DebugStack according to error. Will be added to a stram </Description>
<FormalSpec>pStack:%Library.ListOfDataTypes,pLevel:%Integer</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	for i=1:1:pStack.Count()
	{
		set tElement = pStack.GetAt(i)
		if ($classname(tElement) = "%Library.ListOfDataTypes") {
			do ..StackToStream(tElement,pLevel+1)
		} else {
			if (pLevel > 0) {
				do ..StackOutput.Write("|")
				for j=1:1:pLevel { 
					do ..StackOutput.Write("  |")
				}
				do ..StackOutput.Write("- ")
			}
			do ..StackOutput.WriteLine($Translate(tElement,";",$char(9))) 
		}
	}
]]></Implementation>
</Method>

<Method name="ToString">
<Description>
Prints out the Debug Stack with indentation. </Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	do ..ToGCStream()
	do ..StackOutput.Rewind()
	return ..StackOutput.Read()
]]></Implementation>
</Method>

<Method name="ToGCStream">
<Description>
Create a GlobalCharacterStream containing the stack of information. </Description>
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<Implementation><![CDATA[
	set ..StackOutput = ##class(%Stream.GlobalCharacter).%New()
	do ..StackToStream(..StackLines,0)
	return ..StackOutput
]]></Implementation>
</Method>
</Class>
</Export>
